import { NestFactory } from '@nestjs/core';
import { AppModule } from './app/app.module';
import { Account } from './app/shared/models/account';
import { UserRole } from '@devdude/common';
import * as bcrypt from 'bcrypt';
import { Logger } from '@nestjs/common';

async function bootstrap() {
  const logger = new Logger('Seed');
  const app = await NestFactory.createApplicationContext(AppModule);

  try {
    const accountModel = app.get<typeof Account>('AccountRepository');
    // Note: Depending on how Sequelize is injected, we might need to get the model differently.
    // Usually with @InjectModel(Account) in a service, but here we are in a script.
    // A safer way is to create a SeederService and get that from the app context.
    // Or just use the model directly if it's a static Sequelize model, but NestJS wrapper might be different.

    // Let's try to get the repository if registered, or use a service.
    // Actually, let's create a temporary service or just use the model if it's available via module.
    // But `typeof Account` injection token is usually just the value 'AccountRepository' or similar if using @nestjs/sequelize?
    // Let's check how it's injected in AccountAdminService.
    // @InjectModel(Account) private accountModel: typeof Account

    // To keep it simple and robust, I'll assume standard NestJS/Sequelize behavior.
    // However, getting the provider by token might be tricky if we don't know the exact token generated by @nestjs/sequelize.
    // It is usually the model class itself or a string.

    // Alternative: Use the AccountAdminService if it's exported and available.
    // But AccountAdminService is in AdminModule.

    // Let's try to find the AccountAdminService from the app context.
    // It might be private to the module, so we might not be able to get it directly unless we import AdminModule.

    // Let's rely on the fact that Sequelize models are often accessible if we have the connection.
    // But let's try to get the AccountAdminService first, as it already has the logic.
    // If AdminModule is imported in AppModule, we might be able to get it.

    // Wait, AccountAdminService has `createAccount` which checks for existence.
    // But `createAccount` takes a DTO.

    // Let's try to get the AccountAdminService.
    // If that fails, we can try to get the model.

    // Actually, to avoid "Service not found" errors if it's not exported,
    // I will write a small SeederService inside this file or just try to use the model.
    // The token for @InjectModel(Account) is usually the string 'AccountRepository' ? No, it's usually the class itself if using `sequelize-typescript`.
    // Let's check `apps/core/src/app/admin/account/account-admin.service.ts` again.
    // `@InjectModel(Account) private accountModel: typeof Account`
    // The token is `Account`.

    const accountRepository = app.get(Account); // This should work if Account is a provider.

    // If that fails, we might need `getModelToken(Account)` from @nestjs/sequelize.
  } catch (e) {
    // Fallback or error handling
  }

  // RETHINK:
  // Best practice for seeding in NestJS is to have a SeederModule.
  // But for a quick script:

  const accountRepository = app.get<typeof Account>(Account);

  const adminEmail = 'admin@devdude.com';

  const existingAdmin = await accountRepository.findOne({
    where: { email: adminEmail },
  });

  if (existingAdmin) {
    logger.log('Admin account already exists.');
  } else {
    const passwordHash = await bcrypt.hash('MichaelDudeJs!', 10);

    await accountRepository.create({
      email: adminEmail,
      fullName: 'System Admin',
      passwordHash,
      role: UserRole.ADMIN,
      isActive: true,
    } as any);

    logger.log(`Admin account created: ${adminEmail} / MichaelDudeJs!`);
  }

  await app.close();
}

bootstrap();
